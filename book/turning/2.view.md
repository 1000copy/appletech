
# View

视图类UIView定义了一个矩形区域，并且管理此区域内的用户交互。视图可以加入子视图，全部子视图和自身视图一起，构成一个层次化的视图树。

我们创建一个案例来演示视图的能力：

1. 创建3个矩形，分别为a、b、c
2. a和b并排在一起，c嵌在b内
3. 背景色分别为红、黄、蓝
4. 当点击b矩形时，c会切换颜色，在蓝色和绿色之间切换。

代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController{
        var a : UIView!
        var b : UIView!
        var c : UIView!
        override func viewDidLoad() {
            super.viewDidLoad()
            a = UIView()
            a.frame = CGRect(x: 0, y: 50, width: 50, height: 50)
            view.addSubview(a)
            a.backgroundColor = .red
            b = UIView()
            b.frame = CGRect(x: 50, y: 50, width: 50, height: 50)
            view.addSubview(b)
            b.backgroundColor = .yellow
            c = UIView()
            c.frame = CGRect(x: 0, y: 0, width: 25, height: 25)
            b.addSubview(c)
            c.backgroundColor = .blue
            let gesture = UITapGestureRecognizer(target: self, action: #selector(action(_:)))
            b.addGestureRecognizer(gesture)
        }
        func action(_ sender:UIButton!){
            c.backgroundColor = (c.backgroundColor == .green) ?  .blue :  .green
        }
    }

此案例构建的视图共3个层次，层次树为：

	view
	-- a
	-- b
	----c

视图可以通过方法addSubview来加入子视图，每个子视图的位置和大小可以通过属性.frame设置。UITapGestureRecognizer可以为UIView添加手势操作。

UIView作为基础类，定义了视图的共同属性和行为，但是在实际代码中并不常用。常用的是它的子类，比如UIButton、UILabel等，它的常用子类会在下文讲解。











## ActivityIndicatorView

UIActivityIndicatorView是一个特殊的视图，其外观就像菊花，可以让让旋转起来，以便指示当前有任务正在进行中。

案例代码显示一个ActivityIndicatorView，代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page :UIViewController{
        var v : UIActivityIndicatorView?
        override func viewDidLoad() {
            v = UIActivityIndicatorView()
            v!.frame = CGRect(x: 100, y: 100, width: 100, height: 100)
            view.addSubview(v!)
            view.backgroundColor = .blue
        }
        override func viewDidAppear(_ animated: Bool) {
            v!.startAnimating()
        }
        override func viewDidDisappear(_ animated: Bool) {
            v!.stopAnimating()
        }
    }

运行此代码，当你看到蓝色的背景和旋转的菊花形状，就说明代码已经正常工作。和一般的视图一样，加入的步骤也是：

1. 通过.addSubview方法，把它加入到父视图内
2. 通过设置frame，来设置此视图在它的父视图中的位置和大小

之后的视图添加到父视图的流程不再特别说明。


## CollectionView

类UICollectionView管理一个有序的数据项目集合，并使用定制的布局展示它们。

假设我们希望以流式布局方式来显示一个多部分的集合，第一个部分是计算机语言，第二个部分是操作系统，内容像是这样：

    [["Java","Swift","JavaScript","PHP","Python"],["OS X","Windows","Linux"]]

那么，使用UICollectionView是非常恰当的，示例代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController, UICollectionViewDelegateFlowLayout, UICollectionViewDataSource {
        var items = [["Java","Swift","JavaScript","PHP","Python"],["OS X","Windows","Linux"]]
        var collectionView: UICollectionView!
        override func viewDidLoad() {
            super.viewDidLoad()
            let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout()
            layout.sectionInset = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
            layout.itemSize = CGSize(width: 80, height: 60)
            var frame = view.frame
            frame.origin.y += 30
            collectionView = UICollectionView(frame: frame, collectionViewLayout: layout)
            collectionView.dataSource = self
            collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "Cell")
            collectionView.backgroundColor = UIColor.white
            self.view.addSubview(collectionView)
        }
        func numberOfSections(in collectionView: UICollectionView) -> Int{
            return items.count
        }
        func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
            return items[section].count
        }
        
        func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
            cell.backgroundColor = .blue
            let l = UILabel()
            l.text = items[indexPath.section][indexPath.row]
            l.frame =  CGRect(x: 0.0, y: 0.0, width: 100.0,height: 20.0 )
            cell.addSubview(l)
            return cell
        }
    }
        
此类也需要实现一个数据源协议：UICollectionViewDataSource。通过此协议实现，可以告知UICollectionView需要展示的数据源的必要信息：

1. 有多少部分
2. 每个部分有多少项目
3. 每个项目的Cell实例

本文中的Cell实例内有一个UILabel的子视图，其文本内容就是要展示的项目的文本内容。

在函数

     func viewDidLoad() 

中，使用了UICollectionViewFlowLayout作为UICollectionView的布局管理类。此布局类可以通过属性sectionInset指定每个Cell的四方位置的空隙，可以通过属性itemSize指定每个Cell的大小。


## ImageView

UIImageView可以显示一张图、或者一组动图。

如下案例代码可以显示一张图片：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    extension UIImage {
        class func imageWithColor(_ color: UIColor) -> UIImage {
            let rect = CGRect(x: 0.0, y: 0.0, width: 10.0,height: 10.0 )
            UIGraphicsBeginImageContext(rect.size)
            let context = UIGraphicsGetCurrentContext()
            context?.setFillColor(color.cgColor)
            context?.fill(rect)
            let image = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()               
            return image!
        }
    }
    class Page: UIViewController {
        var bgImage: UIImageView!
        override func viewDidLoad() {
            super.viewDidLoad()
            bgImage = UIImageView()
            bgImage!.frame = CGRect(x: 0,y: 0,width: 100,height: 100)
            bgImage.image = UIImage.imageWithColor(UIColor.red)
            self.view.addSubview(bgImage!)
        }
    }

需要做的就是实例化UIImageView后，把属性.image赋值为UIImage的实例，后者可以用来装入图片。这里再次使用UIImage的扩展函数：

    class func imageWithColor(_ color: UIColor) -> UIImage 

现场生产一张指定颜色填充的图片，通过传递不同的颜色值，就可以得到不同颜色的小方块图片对象。

如果想要显示一组动图，可以这样写代码：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    extension UIImage {
        class func imageWithColor(_ color: UIColor) -> UIImage {
            let rect = CGRect(x: 0.0, y: 0.0, width: 10.0,height: 10.0 )
            UIGraphicsBeginImageContext(rect.size)
            let context = UIGraphicsGetCurrentContext()
            context?.setFillColor(color.cgColor)
            context?.fill(rect)
            let image = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()               
            return image!
        }
    }
    class Page: UIViewController {
        var bgImage: UIImageView!
        override func viewDidLoad() {
            super.viewDidLoad()
            bgImage = UIImageView()
            bgImage.animationImages = [UIImage.imageWithColor(UIColor.red),
                                       UIImage.imageWithColor(UIColor.yellow),
                                       UIImage.imageWithColor(UIColor.black),
                                       UIImage.imageWithColor(UIColor.blue)]
            bgImage!.frame = CGRect(x: 0,y: 0,width: 100,height: 100)
            self.view.addSubview(bgImage!)
            bgImage.animationDuration = 1
            bgImage.startAnimating()
        }
        override func viewDidDisappear(_ animated: Bool) {
            bgImage.stopAnimating()
        }
    }

运行代码时，你可以看到一个矩形区域正在切换4个图片的显示，每个图片是一种颜色。

UIImageView可以响应事件，如下代码演示轻按事件：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    extension UIImage {
        class func imageWithColor(_ color: UIColor) -> UIImage {
            let rect = CGRect(x: 0.0, y: 0.0, width: 10.0,height: 10.0 )
            UIGraphicsBeginImageContext(rect.size)
            let context = UIGraphicsGetCurrentContext()
            context?.setFillColor(color.cgColor)
            context?.fill(rect)
            let image = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()               
            return image!
        }
    }
    class Page: UIViewController {
        var v: UIImageView!
        override func viewDidLoad() {
            super.viewDidLoad()
            let image1 = UIImage.imageWithColor(UIColor.red)
            let image2 = UIImage.imageWithColor(UIColor.blue)
            v = UIImageView(image: image1,highlightedImage:image2)
            v!.frame = CGRect(x: 0,y: 0,width: 100,height: 100)
            self.view.addSubview(v!)
            let tapGestureRecognizer = UITapGestureRecognizer(target:self, action:#selector(imageTapped(_:)))
            v.isUserInteractionEnabled = true
            v.addGestureRecognizer(tapGestureRecognizer)
        }
        func imageTapped(_ img: AnyObject)
        {
            v.isHighlighted = !v!.isHighlighted
        }
    }

通过UITapGestureRecognizer手势识别类可以为UIImageView添加触控事件，此特性常常可以被利用来制作图片按钮。UIImageView本身支持正常图片和高光图片的切换，当轻按事件发生时，可以通过设置属性isHighlighted来切换图片的显示。





## PickerView

UIPickerView看起来是类似机械密码锁一样风格的控件。它可以提供一组或者多组值的显示和选择。

如下代码展示了此控件的能力：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    // picker view
    class Page: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource {
        var p: UIPickerView!
        let values = [["1", "2", "3"],["one", "two", "three"]]
        func numberOfComponents(in pickerView: UIPickerView) -> Int{
            return 2
        }
        func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int{
            return values[component].count
        }
        func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? {
            return values[component][row]
        }
        func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int){
            print(values[component][row])
        }
        func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -> CGFloat {
            return 100
        }
        override func viewDidLoad() {
            super.viewDidLoad()
            view.backgroundColor = UIColor.white
            // 这个frame太小的话，会看不到文字，以至于误以为代码错误。
            p = UIPickerView()
            p.frame =  CGRect(x: 10,y: 50,width: 320,height: 200)
            p.dataSource = self
            p.delegate = self
            view.addSubview(p)
        }
    }

本案例提供了2组数据集合供控件用来显示可选择的内容。为了提供数据给控件，需要实现UIPickerViewDataSource协议；为了监听事件，需要实现UIPickerViewDelegate协议。




## ProgressView

进度条类UIProgressView用来显示进度。

如下案例显示一个进度条：

	import UIKit
	@UIApplicationMain
	class AppDelegate: UIResponder, UIApplicationDelegate {
	    var window: UIWindow?
	    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
	        self.window = UIWindow(frame: UIScreen.main.bounds)
	        self.window!.rootViewController = Page()
	        self.window?.makeKeyAndVisible()
	        return true
	    }
	}
	class Page: UIViewController{
	    var timer : Timer!
	    var pv: UIProgressView!
	    var pv1: UIProgressView!
	    override func viewDidLoad() {
	        super.viewDidLoad()
	        view.backgroundColor = UIColor.white
	        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(Page.update), userInfo: nil, repeats: true)
	        pv = UIProgressView()
	        pv.frame = CGRect(x: 100, y: 100, width: 100, height: 10)
	        view.addSubview(pv)
	        pv.progress = 0.51
	        pv.progressViewStyle = .bar

	    }
	    func update() {
	        pv.progress = pv.progress +  0.01
	        if pv.progress >= 1 {
	            pv.progress = 0
	        }
	    }
	}

运行后，界面上显示一个蓝色的、自动推进的进度条。

特别注意的是，进度值范围从0到1，而不是从0到100，如果需要一个刻度的进展，那么在属性progress的值上加0.01即可。
## ScrollView

UIScrollView支持显示尺寸比控件更大的内容。允许用户通过手势来滑动内容，以便显示本来看不到的内容。

如下代码展示了UIScrollView的功能：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController {
        var scroll: UIScrollView!
        override func viewDidLoad() {
            super.viewDidLoad()
            view.backgroundColor = UIColor.white
            self.scroll = UIScrollView()
            scroll.backgroundColor = UIColor.red
            self.scroll.contentSize = CGSize(width: 100, height: 300)
            scroll.frame = CGRect(x: 100, y: 100, width: 100, height: 100)
            for i in 0  ..< 3 {
                let b = UILabel()
                b.backgroundColor = UIColor.blue
                b.frame = CGRect(x: 0, y: CGFloat(100 * i) , width: 100, height: 100)
                b.backgroundColor = UIColor.green
                b.text = "Drag Me ! "
                scroll.addSubview(b)
            }
            view.addSubview(scroll)
        }
    }

运行后，你可以看到一个绿色的矩形框，以及框内的一个文字。其实文字框共有三个，但是你只能看到一个。你可以通过手势，或者如果在模拟器内，你可以使用鼠标向上拖动，把本来因为控件比内容小而不得不隐藏的内容给拖出来。

你可以看到本案例运行后，在横向（宽度方向）并不能拖动，因为内容宽度、控件宽度是一致的，因此横向拖动并不是必要的。

## SearchBar

UISearchBar实现了一个用于填写文本以便搜索的控件。它由一个文本框、一个搜索按钮、一个书签按钮、一个取消按钮构成。此视图本身并不执行真正的搜索，而是通过实现UISearchBarDelegate协议，在协议指定的函数内执行代码去完成真正的搜索。

演示代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController,UISearchBarDelegate{
        var c : UISearchBar!
        override func viewDidLoad() {
            super.viewDidLoad()
            c = UISearchBar()
            c.frame = CGRect(x: 100, y: 100, width: 200, height: 50)
            view.addSubview(c)
            c.delegate = self
        }
        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
            print ("search : \(searchBar.text)")
        }
    }

默认情况下，只是显示搜索按钮。如果想要显示书签按钮和取消按钮，需要这样

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController,UISearchBarDelegate{
        var c : UISearchBar!
        override func viewDidLoad() {
            super.viewDidLoad()
            c = UISearchBar()
            c.frame = CGRect(x: 100, y: 100, width: 200, height: 50)
            view.addSubview(c)
            c.delegate = self
            c.showsCancelButton = true
            c.showsBookmarkButton = true 
        }
        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
            print ("search : \(searchBar.text)")
        }
        func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) {
            print ("bookmark : \(searchBar.text)")
        }
        func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
            print ("cancel : \(searchBar.text)")
        }
    }

在启动后设置属性：

        c.showsCancelButton = true
        c.showsBookmarkButton = true 

相应的按钮事件处理也在UISearchBarDelegate协议指定的函数中，分别是：

        func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) 
和
        func searchBarCancelButtonClicked(_ searchBar: UISearchBar) 

            


## TableView

类UITableView是一个视图，它可以显示列表，并且列表可以分为多个分区（section）。

### 显示列表

假设一个案例：

1. 显示计算机语言清单（["java","swift","js"]和操作系统的清单 ["Windows","OS X","Linux"]
2. 这个清单在一个UITableView上做分区显示，分为两个区间，分别为Lang和OS

那么代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 50,width: 300,height: 500)
            self.view.addSubview(a)
        }
    }
    
    
    class Table : UITableView,UITableViewDataSource,UITableViewDelegate{
        let sect = ["Lang","OS"]
        let lang = ["java","swift","js"]
        let os = ["Windows","OS X","Linux"]
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.delegate = self
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func numberOfSections(in: UITableView) -> Int {
            return 2
        }
        func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
            let rect = CGRect(x: 0, y: 0, width: tableView.frame.size.width, height: 44)
            let footerView = UILabel(frame:rect)
            footerView.text = sect[section]
            return footerView
        }
        func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
            return 44
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return section == 0 ?lang.count:os.count
        }
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let arr = indexPath.section == 0 ? lang:os
            let a = UITableViewCell(style: .default, reuseIdentifier: nil)
            a.textLabel?.text = String(describing:arr[indexPath.row])
            return a
        }
    }

代码中Page继承于UIViewController，并且在载入时把Table作为子视图加入进来。

类Table继承于UITableView，并实现UITableViewDataSource,UITableViewDelegate，然后配合代码：

    self.dataSource = self
    self.delegate = self

就设置了UITableView的数据源对象为Table对象，指明此对象是UITableView的数据提供者。随后指定委托对象为Table对象，也就指明此对象是UITableView的外观和行为的提供者。

在此类内实现数据源协议的相关方法有：


    func numberOfSections(in: UITableView) -> Int {
        return 2
    }
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return section == 0 ?lang.count:os.count
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let arr = indexPath.section == 0 ? lang:os
        let a = UITableViewCell(style: .default, reuseIdentifier: nil)
        a.textLabel?.text = String(describing:arr[indexPath.row])
        return a
    }
            
第一个方法告诉TableView此列表共有两个区间要去显示。第二个方法告诉TableView此列表指定区间的行数，第三个方法告诉TableView指定的区间和行数的UITableViewCell对象值。

实现以下委托方法，可以定制TableView的外观：

    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let rect = CGRect(x: 0, y: 0, width: tableView.frame.size.width, height: 44)
        let footerView = UILabel(frame:rect)
        footerView.text = sect[section]
        return footerView
    }
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 44
    }
            
第一个方法为指定的区间创建一个头视图，第二个方法指示指定区间的行高。

协议UITableViewDataSource,UITableViewDelegate还有很多可以实现的方法，具体参考iOS的开发者官方文档。

### 添加删除修改

类UITableView不但可以显示内容，还可以实现添加删除修改数据的UI支持。接下来的代码会：

1. 用户可以看到分区显示语言和操作系统的列表
2. 用户可以查看到列表内容添加删除修改

代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 50,width: 300,height: 500)
            self.view.addSubview(a)
        }
    }      
    class Table : UITableView,UITableViewDataSource,UITableViewDelegate{
        var sect = NSMutableArray.init(array: ["Lang","OS"])
        var lang = NSMutableArray.init(array: ["java","swift","js"])
        var os = NSMutableArray.init(array:["Windows","OS X","Linux"])
        var t = Timer()
        var count  = 0
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.delegate = self
            t.invalidate()
            t = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(self.update), userInfo: nil, repeats: true);
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func update() {
            if count == 0 {
                os[0] = "Win"
                
            }else if count == 1 {
                os.add("FreeBSD")
            }else if count == 2 {
                lang.removeObject(at: 0)
            }
            count += 1
            if count >= 3 {
                 t.invalidate()
            }
            self.reloadData()
        }
        func numberOfSections(in: UITableView) -> Int {
            return sect.count
        }
        func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
            let rect = CGRect(x: 0, y: 0, width: tableView.frame.size.width, height: 44)
            let footerView = UILabel(frame:rect)
            footerView.text = String(describing: sect[section])
            return footerView
        }
        func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
            return 44
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return section == 0 ?lang.count:os.count
        }
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let arr = indexPath.section == 0 ? lang  as NSArray :os  as NSArray
            let a = UITableViewCell(style: .default, reuseIdentifier: nil)
            a.textLabel?.text = String(describing:arr[indexPath.row])
            return a
        }
    }


此代码和上一节的代码相比，不同在于：

1. 之前的计算机语言数组和操作系统数据被改成了可变的数组，因为在这个代码中，我们需要修改数据来验证对UITableView的修改
2. 在Table的init函数内，创建一个Timer，它每秒激发一个定时器事件，在不同的激发次数中，分别对数据做修改、添加、删除
3. 调用reload方法，从而让UITableView重新加载数据

对数据的增加修改删除，可以通过.reload方法传递到TableView界面上。

### 默认提供的删除和列表重排

可以自己添加按钮并执行对UITableView的列表的删除和重排。但是也可以使用它自己提供了删除和重排的UI。其中，删除流程是这样的：

1. 用户设置UITableView为编辑模式
2. 系统在当前行内容的基础上，自动加入删除按钮（内容左侧，红色的减号图标），以及重排按钮（内容右侧）
3. 用户可以选择点击删除按钮，系统向左推移内容，显示一个delete按钮
4. 用户点击delete按钮，系统就会调用程序员实现的委托对象的函数：func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: 
IndexPath)，执行真正的删除

而重排流程是这样的：

1. 用户设置UITableView为编辑模式
2. 系统在当前内容的基础上，加上删除按钮（内容左侧，红色的减号图标），以及重排按钮（内容右侧）
3. 用户可以选择按住拖动重排按钮，系统可视化这样拖动过程
4. 用户拖动完成，系统就会调用程序员实现的委托对象的函数： func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)，执行真正的重排


代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
        self.window = UIWindow(frame: UIScreen.main.bounds)
        let page = Page()
        page.view.backgroundColor = .blue
        self.window!.rootViewController = page
        self.window?.makeKeyAndVisible()
        return true
    }
    }
    class Page: UIViewController {
    var a : Table?
    override func viewDidLoad() {
        super.viewDidLoad()
        a  = Table()
        a!.frame = CGRect(x: 0,y: 200,width: 300,height: 200)
        self.view.addSubview(a!)
        let b = UIButton()
        b.setTitle("edit", for: UIControlState())
        b.backgroundColor = UIColor.red
        b.addTarget(self, action: #selector(edit(_:)), for: .touchDown)
        
        let e = UIButton()
        e.setTitle("Done", for: UIControlState())
        e.backgroundColor = UIColor.blue
        e.addTarget(self, action: #selector(done(_:)), for: .touchDown)
        
        let sv = UIStackView()
        
        sv.backgroundColor = UIColor.gray
        sv.axis = UILayoutConstraintAxis.horizontal
        sv.distribution = .equalCentering;
        sv.alignment = .center;
        sv.spacing = 10;
        sv.frame = CGRect(x: 0,y: 100,width: 300,height: 50)
        sv.addArrangedSubview(b)
        
        sv.addArrangedSubview(e)
        sv.translatesAutoresizingMaskIntoConstraints = true
        self.view.addSubview(sv)
        
    }
    func edit( _ b : UIButton!){
        a!.setEditing(true, animated: true)
    }
    func done( _ b : UIButton!){
        a!.setEditing(false, animated: true)
    }
    }
    class Table : UITableView,UITableViewDataSource,UITableViewDelegate{
        var arr = NSMutableArray.init(array: ["java","swift","js"])
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.delegate = self
            
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let a = UITableViewCell(style: .default, reuseIdentifier: nil)
            a.textLabel?.text = String(describing: arr[indexPath.row])
            return a
        }
        func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
            if editingStyle ==  .delete{
                arr.removeObject(at: indexPath.row) 
                self.deleteRows(at: [indexPath], with: UITableViewRowAnimation.fade)
            }
        }
        func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool
        {
            return true;
        }
        func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
            
            let s = sourceIndexPath.row
            let d = destinationIndexPath.row
            let temp = arr[s]
            arr.removeObject(at: s)
            arr.insert(temp, at: d)
        }
    }

注意，代码中：

    func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool
    {
        return true;
    }

此函数需要实现，从而告诉UITableView那些行是可以拖动重排的。这里全部返还true，表示所有内容都可以重排。


### TableView的装饰界面

除了显示section和row之外，TableView可以加入表头表位，节头节尾，帮助程序员更好的组织内容。

我们现在来展示了一个有两个section，每个section有行的界面。通过代码加入了表头表尾、节头节尾。如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Table : UITableView,UITableViewDataSource{
        let arrs = [["Row 1","Row 2"],["Row 1"]]
        let titles  = ["Section Title 1","Section Title 2"]
        let footers  = ["Section Footer 1","Section Footer 2"]
        let tableheader = "Table Header"
        let tablefooter = "Table Footer"
        convenience init(){
            self.init(frame: CGRect.zero, style:UITableViewStyle.grouped)
        }
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.tableHeaderView = UIView()
            self.tableHeaderView!.frame = CGRect(x: 0, y: 0,width: 200,height: 20)
            let l = UILabel()
            l.text = tableheader
            l.frame = CGRect(x: 0, y: 0,width: 200,height: 20)
            self.tableHeaderView?.addSubview(l)
            
            self.tableFooterView = UIView()
            self.tableFooterView!.frame = CGRect(x: 0, y: 0,width: 200,height: 20)
            let f = UILabel()
            f.text = tablefooter
            f.frame = CGRect(x: 0, y: 0,width: 200,height: 20)
            self.tableFooterView?.addSubview(f)
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arrs[section].count
        }
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell{
            let a = UITableViewCell(style: UITableViewCellStyle.value1, reuseIdentifier: nil)
            a.textLabel?.text = String(arrs[indexPath.section][indexPath.row])
            return a
        }
        func numberOfSections(in tableView: UITableView) -> Int{
            return arrs.count
        }
        func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String?{
            return titles[section]
        }
        
        func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String?{
            return footers[section]
        }
    }

    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 30,width: 300,height: 400)
            self.view.addSubview(a)
        }
    }

这里比较特别的是，函数

    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String?{
        return titles[section]
    }

告诉TableView，每个指定section的头标题。

    func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String?{
        return footers[section]
    }

告诉TableView，每个指定section的尾标题。



### 标记

类UITableView支持对每个行做标记和取消标记。标记可以有多种，其中比较常用的是打对号图标。如下代码，演示了如何对每个行打对号标记和取消打对号标记：


    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Table : UITableView,UITableViewDataSource,UITableViewDelegate{
        let arr = ["java","swift","js"]
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.delegate = self
            
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let a = UITableViewCell(style: .default, reuseIdentifier: nil)
            a.textLabel?.text = String(arr[indexPath.row])
            return a
        }
        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath){
            print("did select \(indexPath.row)")
            self.deselectRow(at: indexPath, animated: false)
            if  self.cellForRow(at: indexPath)?.accessoryType !=  .checkmark{
                self.cellForRow(at: indexPath)?.accessoryType = .checkmark
            }else{
                self.cellForRow(at: indexPath)?.accessoryType = .none
            }
        }
    }
    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 30,width: 300,height: 400)
            self.view.addSubview(a)
        }
    }

运行起来后，可看到三个行。点击任何一个行都会在此行的行尾显示一个对号标记，再点击一次就会取消此标记。查询UITableViewCellAccessoryType的官方文档可以得到更多的标记类型。

### 优化：重用cell创建

在之前的代码中，每次调用到函数：

        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell

都需要返回一个UITableViewCell实例。我们都是临时创建此实例并返回的。如果创建的UITableViewCell实例比较多时，可以通过重用已经创建的UITableViewCell实例来提高效率。做法就是：

1. 注册一个UITableViewCell类，指定它的重用标识符
2. 通过重用标识符来获取一个实例

UIKit会在内部对此实例的创建和获取过程优化。使用此优化方案的实例代码如下：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Table: UITableView,UITableViewDataSource{
        let arr = ["javascript","delphi"]
        let MyIdentifier = "cell"
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.register(UITableViewCell.self, forCellReuseIdentifier: MyIdentifier)
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let a = tableView.dequeueReusableCell(withIdentifier: MyIdentifier)!
            a.textLabel?.text = String(arr[indexPath.row])
            return a
        }
    }
    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 30,width: 300,height: 400)
            self.view.addSubview(a)
        }
    }

###复合的Cell

之前的实例代码中创建的Cell的内容都是简单文字，但是实际上每个Cell都可以作为一个视图容器，装入更多的视图。如下代码展示了一个复合的Cell的创建：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }
    class Table : UITableView,UITableViewDataSource{
            let arr = ["java","swift","js"]
            override init(frame: CGRect, style: UITableViewStyle) {
                super.init(frame:frame,style:style)
                self.dataSource = self
            }
            required init?(coder aDecoder: NSCoder) {
                super.init(coder:aDecoder)
            }
            func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
                return arr.count
            }
            
            func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
                let a = UITableViewCell(style: .default, reuseIdentifier: nil)
                a.textLabel?.text = String(arr[indexPath.row])
                let s = UISwitch()
                s.frame = CGRect(x: 0,y: 0,width: 20,height: 20)
                s.addTarget(self, action: #selector(Table.action(_:)), for: .valueChanged)
                s.isOn = true
                a.accessoryView = s
                return a
            }
            func action(_ sender : UISwitch!){
                print(sender.isOn)
            }
        }
    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 30,width: 300,height: 400)
            self.view.addSubview(a)
        }
    }

本案例在每个Cell中添加了一个UISwitch按钮，并且可以如同一般的UIView一样的响应此按钮的事件。


### 默认的Cell风格

可以不必自己定制Cell样式，而是直接使用系统提供的。你可以通过为
1. .style属性
2. textLabel属性
3. detailTextLabel属性
4. .imageView属性
5. .accessoryType属性

而让Cell外观变得丰富多彩：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = Page()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }


    class Page: UIViewController {
        var a : Table!
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = Table()
            a.frame = CGRect(x: 0,y: 30,width: 300,height: 400)
            self.view.addSubview(a)
        }
    }


    class Row {
        var text : String = ""
        var text2 : String = ""
        var image : UIImage
        var access : UITableViewCellAccessoryType
        var style :  UITableViewCellStyle
        init( text : String ,text2:String ,image:UIImage,access:UITableViewCellAccessoryType,style :  UITableViewCellStyle){
            self.text = text
            self.text2 = text2
            self.image = image
            self.access = access
            self.style = style
        }
    }
    class Table: UITableView,UITableViewDataSource{
        let arr = [
            Row(
                text:"java",
                text2:"old plain",
                image:UIImage.imageWithColor(UIColor.red),
                access:UITableViewCellAccessoryType.checkmark,
                style: UITableViewCellStyle.value1),
            Row(
                text:"ruby",
                text2:"new cool slow",
                image:UIImage.imageWithColor(UIColor.green),
                access:UITableViewCellAccessoryType.detailButton,
                style: UITableViewCellStyle.value2),
            Row(
                text:"swift",
                text2:"new cool quick ",
                image:UIImage.imageWithColor(UIColor.blue),
                access:UITableViewCellAccessoryType.detailDisclosureButton,
                style: UITableViewCellStyle.subtitle)
        ]
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let a = UITableViewCell(style: arr[indexPath.row].style, reuseIdentifier: nil)
            a.textLabel?.text = arr[indexPath.row].text
            a.detailTextLabel?.text = arr[indexPath.row].text2
            a.imageView?.image = arr[indexPath.row].image
            a.accessoryType = arr[indexPath.row].access
            return a
        }
    }
    extension UIImage {
        class func imageWithColor(_ color: UIColor) -> UIImage {
            let rect = CGRect(x: 0.0, y: 0.0, width: 10.0,height: 10.0 )
            UIGraphicsBeginImageContext(rect.size)
            let context = UIGraphicsGetCurrentContext()
            
            context?.setFillColor(color.cgColor)
            context?.fill(rect)
            
            let image = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            
            return image!
        }
    }

你可以实际运行此代码，了解不同样式的差异。可以通过官方手册查询UITableViewCellStyle和UITableViewCellAccessoryType的不同选择。

### UITableViewController

我们一直使用UITableView来显示一个列表，也可以使用UITableViewController来完成类似的工作。比如：

    import UIKit
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            let page = LangTableViewController()
            page.view.backgroundColor = .blue
            self.window!.rootViewController = page
            self.window?.makeKeyAndVisible()
            return true
        }
    }

    class LangTableViewController : UITableViewController{
        let arr = ["swift","obj-c","ruby"]
        let MyIdentifier = "cell"
        override func viewDidLoad() {
            super.viewDidLoad()
            tableView.register(UITableViewCell.self, forCellReuseIdentifier: MyIdentifier)
        }
        override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let a = tableView.dequeueReusableCell(withIdentifier: MyIdentifier)
            a!.textLabel?.text = arr[indexPath.row]
            return a!
        }
    }

使用UITableViewController的不同之处在于：

1. 不需要实现UITableViewDataSource和UITableViewDelegate的方法，而是覆盖已经在父类内实现过了的方法
2. 会自动把UITableView填满AppDelegate.window视图内，而不必程序员指定位置和大小



## TextView

UITextView代表了一个多行的、可滚动的、可编辑的内容区域。

代码示例如下：

	import UIKit
	@UIApplicationMain
	class AppDelegate: UIResponder, UIApplicationDelegate {
	    var window: UIWindow?
	    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
	        self.window = UIWindow(frame: UIScreen.main.bounds)
	        self.window!.rootViewController = Page()
	        self.window?.makeKeyAndVisible()
	        return true
	    }
	}
	class Page: UIViewController,UITextViewDelegate{
	    var c : UITextView!
	    override func viewDidLoad() {
	        super.viewDidLoad()
	        c = UITextView()
	        c.frame = CGRect(x: 10, y: 50, width: 200, height: 400)
	        view.addSubview(c)
	        c.text = "text\nand new lines\nand more lines"
	        c.delegate = self
	    }		    
	    func textViewDidChange(_ textView: UITextView){
	        print ("new value : \(c.text)")
	    }
	}

执行后，可以看到一个矩形区域，内部有一些文字。当在此区域内输入内容时，会在控制台打印新的内容。

实现协议UITextViewDelegate，并设置.delegate属性后，就可以在类内接受事件，比如：

	func textViewDidChange(_ textView: UITextView){
        print ("new value : \(c.text)")
    }

此事件会在内容改变时被调用。

## WebView

UIWebView用来在App内嵌入Web页面。如下代码装入Apple.com官方首页在App内:

    import UIKit
    class Page: UIViewController{
        var c : UIWebView!
        override func viewDidLoad() {
            super.viewDidLoad()
            c = UIWebView()
            c.frame = super.view.frame
            view.addSubview(c)
            c.frame.origin.y += 20
            let url = URL(string:"http://apple.com")
            let ro = URLRequest(url:url!)
            c.loadRequest(ro)
        }
    }
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
            self.window = UIWindow(frame: UIScreen.main.bounds)
            self.window!.rootViewController = Page()
            self.window?.makeKeyAndVisible()
            return true
        }
    }

关键代码在于：

    let url = URL(string:"http://apple.com")
    let ro = URLRequest(url:url!)
    c.loadRequest(ro)

构建URL对象和URLRequest请求对象，然后使用WebView的方法loadRequest装入请求，即可加载页面在WebView内。

